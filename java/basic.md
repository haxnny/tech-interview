## 가비지 컬렉션이란?
* 자바가 실행되는 JVM에서 사용되는 객체, 즉 Heap 영역의 객체를 관리해 주는 기능
* 이 과정에서 stop the world 가 일어나게 되며, 일련 과정을 효율적으로 하기 위해 가비지 컬렉터 변경 또는 세부 값 조정이 필요
> 키워드 & 꼬리 질문
> * 가비지 컬렉션 과정, 가비지 컬렉터 종류에 대한 이해


## Call(Pass) by Value 와 Call(Pass) by Reference 차이
* 메서드 호출 시 파라미터 전달 방법 2가지
* Call by Value
  * 메서드 호출 시 **값**을 넘겨준다.
  * 메서드 호출자 (Caller) 의 변수와 호출 당하는 수신자 (Callee)의 파라미터는 복사된 **서로 다른 변수**이다.
  * 원시 값 만을 전달하기 때문에 수신자의 파라미터를 수정해도 호출자 변수(원본 데이터)에는 아무런 영향이 없다.
* Call by Reference
  * 메서드 호출 시 **참조(주소)**를 직접 전달한다.
  * 참조를 지접 넘기기 때문에, 호출자의 변수와 수신자의 파라미터는 **완전히 동일한 변수**이다.
  * 메서드 내에서 파라미터를 수정하면 호출자 변수(원본 데이터)에도 반영된다.
> JVM 메모리에 변수 저장되는 위치
> * 원시 타입 (Primitive Type) 은 Stack 영역에 변수와 함께 저장
> * 참조 타입 (Reerence Type) 객체는 Heap 영역에 저장되고, Stack 영역에 있는 변수가 객체의 주소 값을 저장


## [StringBuilder 와 StringBuffer의 차이](https://haenny.tistory.com/17)
* 공통점
  * mutation
  * append 등의 api 지원
* 차이점
  * StringBuilder : 동기화를 지원하지 않아 싱글 스레드에서 속도가 빠름
  * StringBuffer : 멀티 스레드 환경에서 동기화 지원하지만, 이런 구현은 로직을 의심해야 함
> 키워드
> * mutation(가변), immutation(불변) 이해
> * 불변 객체인 String의 연산에서 오는 퍼포먼스 이슈 이해
> * String (immutation)
>   * String 문자열 연산 과정에서 불변 객체의 반복 생성으로 퍼포먼스가 낮아짐


## Java 메모리 영역
* 메모리 영역 구분
  * Method 영역 : 클래스가 로딩될 때 생성되며 주로 static 변수가 저장됨
  * Heap 영역 : 런타임 시 할당되며 주로 객체가 저장됨
  * Stack 영역 : 컴파일 시 할당되며 메소드 호출 시 지역 변수가 저장됨
  * PC 레지스터 영역 : 스레드가 생성될 때마다 생성되는 영역으로 다음 명령어의 주소를 저장
  * Native 영역 : 자바 외 언어로 작성된 코드를 위한 영역
* Heap 과 Stack 영역은 같은 메모리 공간을 동적으로 공유하며, 과도하게 사용하는 경우 OOM 발생할 수 있음
* Heap 영역은 참조하는 변수가 없어도 바로 지워지지 않으며 GC를 통해 정리됨
  
|영역|할당 시기|대상|
|------|---|---|
|Method Area (Class Area)|클래스 로딩될 때 생성됨|static 변수|
|Stack Area|컴파일 타임 시 할당됨|지역 변수 등 임시 값|
|Heap Area|런타임 시 할당됨|new 키워드로 생성되는 객체와 배열|

## 오버로딩과 오버라이딩 차이
* 오버로딩 (Overload)
  * 동일한 메소드명 & 매개변수 개수나 타입이 다른 메소드 추가 시 사용
* 오버라이딩 (Override)
  * 부모 클래스로부터 상속받은 메소드를 재정의 할 때 사용
> 키워드 & 꼬리질문
> * 오버로딩 : 생성자가 여러 개 필요한 경우 유용
> * 결합도 낮추기 위해 인터페이스 사용이 있으며, 이 과정에서 오버라이딩 적극 사용  

## 추상클래스와 인터페이스 차이
* 추상클래스 (Abstract Class) : extends **Abstract Class is A**
  * 단일 상속 지원
  * 변수를 가질 수 있음
  * 하나 이상의 abstract 메소드 존재
  * 자식 클래스에서 상속을 통해 abstract 메소드 구현 필요
* 인터페이스 (Interface) : implements **Interface has A**
  * 다중 상속 지원
  * 변수를 가질 수 없으며, 상수는 가능
  * 모든 메소드는 선언부만 존재
  * 구현 클래스는 선언된 메소드를 오버라이
> 키워드 & 꼬리질문
> Java 버전이 올라갈수록 abstract의 기능을 interface가 흡수하고 있음
> * java 8 : interface 에서 default method 사용 가능
> * java 9 : interface 에서 private method 사용 가능

## Generic 이란?
* 클래스에서 사용할 타입을 클래스 외부에서 설정하도록 만드는 것
* 제너릭으로 선언한 클래스는 내가 원하는 타입으로 만들어서 사용 가능함
* 코드의 재사용성 UP, 타입체크 & 변환이 필요 없음
* <?> : ?에는 참조자료형(클래스, 인터페이스, 배열)만 사용 가능
  * 기본 자료형 사용하기 위해서는 wrapper 클래스 활용 필요


## 접근 제어자 (Access Modifier) 란?
* public : 모든 접근 허용
* protected : 상속받은 클래스 or 같은 패키지 접근 허용
* default : 기본 제한자. 자신 클래스 내부 or 같은 패키지 접근 허용
* private : 외부 접근 불가능. 같은 클래스 내에서만 접근 허용
> 참고 : 보통 명시적 표현을 선호하여 default 는 잘 쓰이지 않음 


## Java 컴파일 과정
1. 컴파일러가 변환 : 소스코드 → 자바 바이트 코드 (.class)
2. JVM 이 변환 : 바이트 코드 → 기계어
3. 인터프리터 방식으로 애플리케이션 실행
> 키워드 & 꼬리질문
> * JIT 컴파일러 (Just-In-Time)
>   * 바이트 코드 파일로 만든 후 기계어로 변환작업할 때 이 역할을 JVM 안의 JIT 컴파일러가 함 (기계어로 변환하는 데 비용 발생)
>   * 이런 변환 비용 때문에 JVM은 모든 코드를 JIT 컴파일러 사용하는 것이 아닌, 인터프리터 방식을 사용하다 자주 사용되는 코드만 캐싱함
>   * JVM은 내부적으로 어떤 메서드가 얼마나 자주 수행되는지를 확인하고 HotSpot 이라고 판단하면 컴파일을 수행해놓음
> * 인터프리터 vs 컴파일러
>   * 인터프리터 (Interfreter)
>     * 프로그램 실행 시 한문장씩 번역
>     * 컴파일러와 같은 오브젝트 코드 생성 과정이 없어 메모리 효율이 좋으나, 한문장씩 번역 후 실행하기 때문에 시간이 느림
>     * 프로그램 실행 후 오류 발견 시 바로 실행 중지 (실행 후 오류 알 수 있음)
>     * 대표 언어 : Python, Ruby, Javascript 등
>   * 컴파일러 (Compiler)
>     * 전체 파일 스캔하여 한번에 번역
>     * 기계어 번역과정에 더 많은 메모리 사용
>     * 초기 스캔시간이 오래 걸리지만, 한번 실행 파일이 만들어지고 나면 빠름
>     * 전체 코드 스캔 과정에서 모든 오류를 한꺼번에 출력하기 때문에 실행 전 오류를 알 수 있음
>     * 대표적인 언어 : C, C++, JAVA 등

